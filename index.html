<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
body {
  overflow:hidden;
  margin:0;
}

text {
  font-family: sans-serif;
  pointer-events: none;
}
</style>
</head>
<body>
<div>
  <div id="detailsBox" style="z-index: 1; position: absolute" >  </div>
  <div id="svgContainer" />
</div>
<script src="http://d3js.org/d3.v5.min.js"></script>
<script>
var w = window.innerWidth;
var h = window.innerHeight;

var keys = true, keyl = true, keyc = true, keyp = true, keyb = true, keyx = true, key1 = true, key2 = true, key3 = true, key4 = true, key5 = true, key0 = true
var sequencesFilter = [];
var nodeFilterDistance = 2;
var nodeFilter = [];
var infoLinkData;

var focus_node = null, highlight_node = null;

var text_center = false;
var outline = false;

var min_score = 0;
var max_score = 1;

var color = d3.scaleLinear()
  .domain([min_score, (min_score+max_score)/2, max_score])
  .range(["lime", "yellow", "red"]);

var highlight_color = "blue";
var highlight_trans = 0.1;

var force = d3.forceSimulation();

var default_node_color = "#ccc";
//var default_node_color = "rgb(3,190,100)";
var default_link_color = "#888";
var nominal_base_node_size = 24;
var marker_height_over_width = 1.5;
var marker_height_over_node_size = 1;
var nominal_text_size = 12;
var max_text_size = 34;
var nominal_stroke = 4.5;
var max_base_node_size = 36;
var min_zoom = .1;
var max_zoom = 7;
var svg = d3.select("#svgContainer").append("svg");

// build the arrow.
marker_height = marker_height_over_node_size * nominal_base_node_size;
marker_width = marker_height / marker_height_over_width;
svg.append("svg:defs").selectAll("marker")
  .data(["end"])      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
  .attr("id", String)
  .attr("viewBox", "0 -5 10 10")
  .attr("refX", nominal_base_node_size + nominal_stroke / 2)
  .attr("refY", 0)
  .attr("markerWidth", marker_width)
  .attr("markerHeight", marker_height)
  .attr("orient", "auto")
  .attr("markerUnits", "userSpaceOnUse") // avoid scaling markers with path stroke-width
  .append("svg:path")
  .attr("d", "M0,-5L10,0L0,5");
var zoom = d3.zoom().scaleExtent([min_zoom,max_zoom]);
var g = svg.append("g");
var links = g.append("g").attr("id", "links");
var texts = g.append("g").attr("id", "texts");
var nodes = g.append("g").attr("id", "nodes");
svg.style("cursor","move");

function updateInfoDisplay(d) {
  var infoBox = d3.selectAll("#detailsBox");
  infoBox.selectAll("*").remove();
  var a = infoBox.selectAll("div")
    .data(d.sequences)
    .enter()
    .append("div")
    .style("clear", "both")
    .append("a");
  a.text(function (d) { return d.sequence_name; });
  a.attr("href", function (d) { return d.video_url; });
}

d3.json("graph.json").then(function(graph) {
  var linkedByIndex = {};
  graph.links.forEach(function(d) {
    linkedByIndex[d.source + "," + d.target] = true;
  });

  function isConnected(a, b) {
    return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
  }

  function hasConnections(a) {
    for (var property in linkedByIndex) {
      s = property.split(",");
      if ((s[0] == a.index || s[1] == a.index) && linkedByIndex[property]) {
        return true;
      }
    }
    return false;
  }

  force
    .nodes(graph.nodes)
    .force("link", d3.forceLink(graph.links)
      .distance(2 * nominal_base_node_size))
    .force("collision", d3.forceCollide(nominal_base_node_size * 3)
      .iterations(3));

  var link = links.selectAll(".link")
    .data(graph.links)
    .enter().append("path")
    .attr("class", "link")
    .style("stroke-width",nominal_stroke)
    .style("stroke", function(d) { 
      if (isNumber(d.score) && d.score>=0) return color(d.score);
      else return default_link_color; })
    .style("fill", "none")
    .attr("marker-end", "url(#end)");

  link.on('click', function(d) {
    infoLinkData = d;
    updateInfoDisplay(infoLinkData);
  });
  link.on('mouseover', function(d) {
    if (!infoLinkData) {
      infoLinkData = d;
    }
    updateInfoDisplay(d);
  });
  link.on('mouseout', function(d) {
    updateInfoDisplay(infoLinkData);
  });

  var node = nodes.selectAll(".node")
    .data(graph.nodes)
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()
      .on("start", function(d) {
        force.alphaTarget(0.8).restart();
        node.each(function(d) {
          d.fx = undefined;
          d.fy = undefined;
        });
        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", function(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      })
      .on("end", function(d) {
        force.alphaTarget(0);
      }));

  node.on("dblclick.zoom", function(d) { d3.event.stopPropagation();
    zoom.translateTo(svg, d.x, d.y);
  });

  var tocolor = "fill";
  var towhite = "stroke";
  if (outline) {
    tocolor = "stroke"
    towhite = "fill"
  }

  var circle = node.append("path")
    .attr("d", d3.symbol()
      .size(function(d) { return Math.PI*Math.pow(nominal_base_node_size,2); }))
    .style(tocolor, function(d) {
      if (isNumber(d.score) && d.score>=0) return color(d.score);
      else return default_node_color; })
    .style("stroke-width", nominal_stroke)
    .style(towhite, "white");

  // Append images
  var images = node.append("svg:image")
    .attr("xlink:href",  function(d) { return d.img;})
    .attr("x", function(d) { return -25;})
    .attr("y", function(d) { return -25;})
    .attr("height", 50)
    .attr("width", 50);

  var setEvents = images
    .on( 'mouseenter', function() {
      // move the current element to the front
      nodes.node().appendChild(this.parentNode);

      // animate enlarging the current element
      d3.select( this )
        .transition()
        .attr("x", function(d) { return -100;})
        .attr("y", function(d) { return -100;})
        .attr("height", 500)
        .attr("width", 500)})
    // set back
    .on( 'mouseleave', function() {
      d3.select( this )
        .transition()
        .attr("x", function(d) { return -25;})
        .attr("y", function(d) { return -25;})
        .attr("height", 50)
        .attr("width", 50)})
    .on( 'mousedown', function() {
      d3.select( this )
        .transition()
        .attr("x", function(d) { return -25;})
        .attr("y", function(d) { return -25;})
        .attr("height", 50)
        .attr("width", 50)});

  var text = texts.selectAll(".text")
    .data(graph.nodes)
    .enter().append("text")
    .attr("dy", "0.5em")
    .style("font-size", nominal_text_size + "px");

  if (text_center) {
    text.text(function(d) { return d.id; })
      .style("text-anchor", "middle");
  } else {
    text.attr("dx", function(d) {return nominal_base_node_size;})
      .text(function(d) { return '\u2002'+d.id; });
  }

  node
    .on("mouseover", function(d) {
      set_highlight(d); })
    .on("click", function(d) {
      //d3.event.stopPropagation();
      //focus_node = d;
      set_focus(d);
      if (highlight_node === null) set_highlight(d);
      sequencesFilter = d.sequences;
      set_node_filter(d.id, nodeFilterDistance);
      update_visibility();
    })
    .on("mouseout", function(d) {
      exit_highlight();});

  d3.select(window).on("mouseup", function() {
      if (focus_node!==null) {
        focus_node = null;
        if (highlight_trans<1) {
          circle.style("opacity", 1);
          text.style("opacity", 1);
          link.style("opacity", 1);
        }
      }
      if (highlight_node === null) exit_highlight();
      //sequencesFilter = [];
      update_visibility();
  });

  function exit_highlight() {
    highlight_node = null;
    if (focus_node===null) {
      svg.style("cursor","move");
      if (highlight_color!="white") {
        circle.style(towhite, "white");
        text.style("font-weight", "normal");
        link.style("stroke", function(o) {
          return (isNumber(o.score) && o.score>=0)?color(o.score):default_link_color
        });
      }
    }
  }

  function set_focus(d) {	
    return;
    if (highlight_trans < 1)  {
      circle.style("opacity", function(o) {
        return isConnected(d, o) ? 1 : highlight_trans;
      });

      text.style("opacity", function(o) {
        return isConnected(d, o) ? 1 : highlight_trans;
      });

      link.style("opacity", function(o) {
        return o.source.index == d.index || o.target.index == d.index ? 1 : highlight_trans;
      });		
    }
  }


  function set_highlight(d) {
    return;
    svg.style("cursor","pointer");
    if (focus_node!==null) d = focus_node;
    highlight_node = d;

    if (highlight_color!="white") {
      circle.style(towhite, function(o) {
        return isConnected(d, o) ? highlight_color : "white";
      });
      text.style("font-weight", function(o) {
        return isConnected(d, o) ? "bold" : "normal";
      });
      link.style("stroke", function(o) {
        return o.source.index == d.index || o.target.index == d.index
          ? highlight_color
          : ((isNumber(o.score) && o.score>=0) ? color(o.score) : default_link_color);
      });
    }
  }

  zoom.on("zoom", function() {
    link.style("stroke-width",nominal_stroke);
    circle.style("stroke-width",nominal_stroke);

    circle.attr("d", d3.symbol()
      .size(function(d) {
        return Math.PI*Math.pow(nominal_base_node_size,2); }))

    if (!text_center) text.attr("dx", function(d) {
      return (nominal_base_node_size); });

    var t = d3.event.transform;
    g.attr("transform", d3.event.transform.toString());
  });

  svg.call(zoom);	  

  resize();
  //window.focus();
  d3.select(window).on("resize", resize).on("keydown", keydown);

  force.on("tick", function() {
    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    text.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    link.attr("d", function(d) {
        // x = max distance from straight line; let x = dist * aspect
        // (dist/2) ^ 2 + (r - x)^2 = r^2
        // (dist/2) ^ 2 + x^2       = 2rx
        // r                        = ((dist/2) ^ 2 + x^2)/2x
        // r                        = ((dist/2) ^ 2 + (dist * aspect)^2)/(2*dist*aspect)
        // r                        = (dist/8/aspect + dist * aspect/2)
        var aspect = 0.1;
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dist = Math.sqrt(dx * dx + dy * dy),
            dr = dist / 8 / aspect + dist * aspect / 2;
        return "M" +
            d.source.x + "," +
            d.source.y + "A" +
            dr + "," + dr + " 0 0,1 " +
            d.target.x + "," +
            d.target.y;
    });

    node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
  });

  function resize() {
    var width = window.innerWidth, height = window.innerHeight;
    svg.attr("width", width).attr("height", height);

    w = width;
    h = height;
  }

  function keydown() {
    if (d3.event.keyCode==32) {
      force.stop();
    } else if (d3.event.keyCode>=48 && d3.event.keyCode<=90 && !d3.event.ctrlKey && !d3.event.altKey && !d3.event.metaKey) {
      switch (String.fromCharCode(d3.event.keyCode)) {
        case "S": keys = !keys; break;
        case "L": keyl = !keyl; break;
        case "C": keyc = !keyc; break;
        case "P": keyp = !keyp; break;
        case "B": keyb = !keyb; break;
        case "X": keyx = !keyx; break;
        case "5": key5 = !key5; break;
        case "4": key4 = !key4; break;
        case "1": key1 = !key1; break;
        case "2": key2 = !key2; break;
        case "3": key3 = !key3; break;
        case "0": key0 = !key0; break;
      }

      update_visibility();
    }
  }

  function update_visibility() {
    link_vis = function(d) {
      return vis(d.source) && vis(d.target) && vis_by_link_score(d.score);
    }

    link.style("display", function(d) {
      var flag = link_vis(d);
      linkedByIndex[d.source.index + "," + d.target.index] = flag;
      return flag ? "inline" : "none";
    });
    node.style("display", function(d) {
      return (key0||hasConnections(d)) && vis(d) ?"inline" : "none";
    });
    text.style("display", function(d) {
      return (key0||hasConnections(d)) && vis(d) ? "inline" : "none";
    });

    if (highlight_node !== null) {
      if ((key0||hasConnections(highlight_node)) && vis(highlight_node)) {
        if (focus_node!==null) set_focus(focus_node);
        set_highlight(highlight_node);
      } else {
        exit_highlight();
      }
    }

    force.stop();
    force.force("link").links(graph.links.filter(link_vis));
    force.restart();
    force.alpha(0.5);
  }

  function set_node_filter(sourceId, numLinks) {
    all = new Set([sourceId])
    current = [sourceId]
    next = []

    for (var linksFollowed = 0; linksFollowed < numLinks; linksFollowed++) {
      current.forEach(function(currentId) {
        graph.links.forEach(function(d) {
          if (d.source.id == currentId && !all.has(d.target.id)) {
            next.push(d.target.id);
            all.add(d.target.id);
          }
        });
      });
      current = next;
      next = [];
    }

    node.each(function(d) {
      d.fx = (d.id == sourceId) ? d.x : undefined;
      d.fy = (d.id == sourceId) ? d.y : undefined;
    });
    nodeFilter = Array.from(all);
  }

  initNodeId = "Bird";
  d = node.filter(function(d) { return d.id == initNodeId }).datum();
  set_node_filter(initNodeId, nodeFilterDistance);
  sequencesFilter = d.sequences;
  zoom.translateTo(svg, d.x, d.y);
  update_visibility();
});

function vis(node) {
  return vis_by_position(node.position) &&
        vis_by_pose_difficulty(node.difficulty) &&
        vis_by_sequence(node.sequences) &&
        vis_by_node(node.id);
}

function vis_by_position(position) {
  switch (position) {
    case "Standing": return keys;
    case "L-Base": return keyl;
    case "Counter Balance": return keyc;
    case "Base Supine": return keyp;
    case "Belly Basing": return keyb;
    case "No Info Yet": return keyx;
    default: return true;
  }
}

function vis_by_pose_difficulty(difficulty) {
  switch (difficulty) {
    case "Easy": return key1;
    case "Intermediate": return key2;
    case "Hard": return key3;
    case "Really Hard": return key4;
    case "Expert": return key5;
    case "No Info Yet": return keyx;
    default: return true;
  }
}

function vis_by_sequence(sequences) {
  if (sequencesFilter.length === 0 || !sequences) {
    return true;
  } else {
    for (var i = 0; i < sequences.length; i++) {
      if (sequencesFilter.map(function(e) { return e.sequence_name; }).indexOf(sequences[i].sequence_name) != -1) {
        return true;
      }
    }
    return false;
  }
}

function vis_by_node(node) {
  if (nodeFilter.length === 0) {
    return true;
  } else {
    return nodeFilter.indexOf(node) != -1;
  }
}

function vis_by_link_score(score) {
  if (isNumber(score)) {
    if (score>=0.666) return keyx;
    else if (score>=0.333) return keyx;
    else if (score>=0) return keyx;
  }
  return true;
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}	

</script>
</body>
</html>
